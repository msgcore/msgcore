import { Test, TestingModule } from '@nestjs/testing';
import { INestApplication } from '@nestjs/common';
import * as path from 'path';
import * as fs from 'fs/promises';
import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

describe('CLI Integration Tests (e2e)', () => {
  let app: INestApplication;
  const testOutputDir = path.join(__dirname, '../test-output/cli-integration');
  const generatedCliDir = path.join(__dirname, '../generated/cli');

  beforeAll(async () => {
    // Clean up test output
    try {
      await fs.rm(testOutputDir, { recursive: true, force: true });
    } catch {
      // Ignore cleanup errors
    }
    await fs.mkdir(testOutputDir, { recursive: true });
  });

  afterAll(async () => {
    // Clean up test output
    try {
      await fs.rm(testOutputDir, { recursive: true, force: true });
    } catch {
      // Ignore cleanup errors
    }
  });

  describe('Generated CLI compilation and execution', () => {
    it('should compile the generated CLI without errors', async () => {
      // CLI should already be generated by CI workflow
      // Just verify it compiles

      // Check that CLI was already built by workflow
      const distPath = path.join(generatedCliDir, 'dist/index.js');
      await fs.access(distPath);

      // Verify CLI can run
      const { stdout } = await execAsync('node dist/index.js --version', {
        cwd: generatedCliDir,
        timeout: 5000,
      });

      // CLI version should match any semantic version
      expect(stdout).toMatch(/\d+\.\d+\.\d+/);
    }, 30000);

    it('should not have duplicate Commander.js options', async () => {
      // Try to load the compiled CLI (this will fail if there are duplicate options)
      const cliIndexPath = path.join(generatedCliDir, 'dist/index.js');

      // Check that the file exists and is executable
      await fs.access(cliIndexPath);

      // Try to run the CLI with --help (this will trigger Commander.js initialization)
      // If there are duplicate options, it will throw before even showing help
      const { stdout, stderr } = await execAsync(
        `node ${cliIndexPath} --help`,
        {
          cwd: generatedCliDir,
          timeout: 5000,
        },
      );

      // Should not have Commander.js duplicate option errors
      expect(stderr).not.toContain('Cannot add option');
      expect(stderr).not.toContain('due to conflicting flag');
      expect(stdout).toContain('msgcore');
    }, 30000);

    it('should show available commands', async () => {
      const cliIndexPath = path.join(generatedCliDir, 'dist/index.js');

      const { stdout } = await execAsync(`node ${cliIndexPath} --help`, {
        cwd: generatedCliDir,
        timeout: 5000,
      });

      // Should list major command groups
      expect(stdout).toContain('projects');
      expect(stdout).toContain('api-keys');
      expect(stdout).toContain('platforms');
      expect(stdout).toContain('messages');
    }, 30000);

    it('should show help for specific commands', async () => {
      const cliIndexPath = path.join(generatedCliDir, 'dist/index.js');

      const { stdout } = await execAsync(
        `node ${cliIndexPath} projects --help`,
        {
          cwd: generatedCliDir,
          timeout: 5000,
        },
      );

      // Should show projects subcommands
      expect(stdout).toContain('list');
      expect(stdout).toContain('create');
    }, 30000);

    it('should show help for api-keys commands without duplicate option errors', async () => {
      const cliIndexPath = path.join(generatedCliDir, 'dist/index.js');

      // This is the command that was failing with duplicate --keyId
      const { stdout, stderr } = await execAsync(
        `node ${cliIndexPath} api-keys --help`,
        {
          cwd: generatedCliDir,
          timeout: 5000,
        },
      );

      expect(stderr).not.toContain('Cannot add option');
      expect(stderr).not.toContain('conflicting flag');
      expect(stdout).toContain('revoke');
      expect(stdout).toContain('roll');
    }, 30000);

    it('should fail gracefully when required options are missing', async () => {
      const cliIndexPath = path.join(generatedCliDir, 'dist/index.js');

      // Try to run a command without required config
      try {
        await execAsync(`node ${cliIndexPath} projects list`, {
          cwd: generatedCliDir,
          timeout: 5000,
          env: {
            ...process.env,
            // Don't set MSGCORE_API_KEY or MSGCORE_API_URL
            MSGCORE_API_KEY: undefined,
            MSGCORE_API_URL: undefined,
          },
        });
        fail('Should have thrown an error');
      } catch (error: any) {
        // Should fail with a network/auth error, not a syntax error
        const output = error.stderr || error.stdout || error.message || '';
        expect(output).not.toContain('SyntaxError');
        expect(output).not.toContain('TypeError');
        expect(output).not.toContain('Cannot find module');
      }
    }, 30000);

    it('should have all required dependencies installed', async () => {
      const packageJson = JSON.parse(
        await fs.readFile(path.join(generatedCliDir, 'package.json'), 'utf-8'),
      );

      // Check runtime dependencies
      expect(packageJson.dependencies).toHaveProperty('@msgcore/sdk');
      expect(packageJson.dependencies).toHaveProperty('commander');
      expect(packageJson.dependencies).toHaveProperty('axios');

      // Check dev dependencies
      expect(packageJson.devDependencies).toHaveProperty('@types/node');
      expect(packageJson.devDependencies).toHaveProperty('typescript');

      // Verify node_modules exist
      await fs.access(path.join(generatedCliDir, 'node_modules'));
      await fs.access(path.join(generatedCliDir, 'node_modules/@msgcore/sdk'));
      await fs.access(path.join(generatedCliDir, 'node_modules/commander'));
    }, 30000);

    it('should have valid TypeScript configuration', async () => {
      const tsconfigPath = path.join(generatedCliDir, 'tsconfig.json');
      await fs.access(tsconfigPath);

      const tsconfig = JSON.parse(await fs.readFile(tsconfigPath, 'utf-8'));

      // Should have proper compiler options
      expect(tsconfig.compilerOptions).toBeDefined();
      expect(tsconfig.compilerOptions.outDir).toMatch(/\.?\/dist/);
      expect(tsconfig.compilerOptions.module).toBeDefined();
    }, 30000);

    it('should generate README with command examples', async () => {
      const readmePath = path.join(generatedCliDir, 'README.md');
      await fs.access(readmePath);

      const readme = await fs.readFile(readmePath, 'utf-8');

      // Should have usage examples
      expect(readme).toContain('msgcore');
      expect(readme).toContain('Installation');
    }, 30000);
  });

  describe('Real world CLI scenarios', () => {
    it('should handle --json flag correctly', async () => {
      const cliIndexPath = path.join(generatedCliDir, 'dist/index.js');

      // Check that --json flag is recognized (won't execute, but should parse)
      const { stdout } = await execAsync(
        `node ${cliIndexPath} projects list --help`,
        {
          cwd: generatedCliDir,
          timeout: 5000,
        },
      );

      expect(stdout).toContain('--json');
    }, 30000);

    it('should handle project parameter correctly', async () => {
      const cliIndexPath = path.join(generatedCliDir, 'dist/index.js');

      const { stdout } = await execAsync(
        `node ${cliIndexPath} api-keys list --help`,
        {
          cwd: generatedCliDir,
          timeout: 5000,
        },
      );

      expect(stdout).toContain('--project');
      expect(stdout).toContain('MSGCORE_DEFAULT_PROJECT');
    }, 30000);
  });

  describe('Config command', () => {
    const testConfigDir = path.join(testOutputDir, '.msgcore');
    const testConfigPath = path.join(testConfigDir, 'config.json');
    const cliIndexPath = path.join(generatedCliDir, 'dist/index.js');

    beforeEach(async () => {
      // Clean up test config before each test
      try {
        await fs.rm(testConfigDir, { recursive: true, force: true });
      } catch {
        // Ignore cleanup errors
      }
    });

    afterEach(async () => {
      // Clean up test config after each test
      try {
        await fs.rm(testConfigDir, { recursive: true, force: true });
      } catch {
        // Ignore cleanup errors
      }
    });

    it('should show config command in help', async () => {
      const { stdout } = await execAsync(`node ${cliIndexPath} --help`, {
        cwd: generatedCliDir,
        timeout: 5000,
      });

      expect(stdout).toContain('config');
      expect(stdout).toContain('Manage CLI configuration');
    }, 30000);

    it('should show config subcommands', async () => {
      const { stdout } = await execAsync(`node ${cliIndexPath} config --help`, {
        cwd: generatedCliDir,
        timeout: 5000,
      });

      expect(stdout).toContain('set <key> <value>');
      expect(stdout).toContain('get <key>');
      expect(stdout).toContain('list');
    }, 30000);

    it('should set and get configuration values', async () => {
      // Override HOME to use test directory
      const env = { ...process.env, HOME: testOutputDir };

      // Set a config value
      const { stdout: setOutput } = await execAsync(
        `node ${cliIndexPath} config set apiUrl https://test.example.com`,
        { cwd: generatedCliDir, timeout: 5000, env },
      );

      expect(setOutput).toContain('Set apiUrl');
      expect(setOutput).toContain('https://test.example.com');

      // Get the config value
      const { stdout: getOutput } = await execAsync(
        `node ${cliIndexPath} config get apiUrl`,
        { cwd: generatedCliDir, timeout: 5000, env },
      );

      expect(getOutput).toContain('apiUrl');
      expect(getOutput).toContain('https://test.example.com');
    }, 30000);

    it('should mask API key in output', async () => {
      const env = { ...process.env, HOME: testOutputDir };

      // Set API key
      const { stdout: setOutput } = await execAsync(
        `node ${cliIndexPath} config set apiKey msc_test_secret_key_12345`,
        { cwd: generatedCliDir, timeout: 5000, env },
      );

      expect(setOutput).toContain('Set apiKey');
      expect(setOutput).toContain('***');
      expect(setOutput).not.toContain('msc_test_secret_key_12345');

      // Get API key
      const { stdout: getOutput } = await execAsync(
        `node ${cliIndexPath} config get apiKey`,
        { cwd: generatedCliDir, timeout: 5000, env },
      );

      expect(getOutput).toContain('apiKey');
      expect(getOutput).toContain('***');
      expect(getOutput).not.toContain('msc_test_secret_key_12345');
    }, 30000);

    it('should list all configuration', async () => {
      const env = { ...process.env, HOME: testOutputDir };

      // Set multiple values
      await execAsync(
        `node ${cliIndexPath} config set apiUrl https://test.example.com`,
        { cwd: generatedCliDir, timeout: 5000, env },
      );
      await execAsync(
        `node ${cliIndexPath} config set defaultProject test-project`,
        { cwd: generatedCliDir, timeout: 5000, env },
      );

      // List config
      const { stdout } = await execAsync(`node ${cliIndexPath} config list`, {
        cwd: generatedCliDir,
        timeout: 5000,
        env,
      });

      expect(stdout).toContain('apiUrl');
      expect(stdout).toContain('https://test.example.com');
      expect(stdout).toContain('defaultProject');
      expect(stdout).toContain('test-project');
    }, 30000);

    it('should create config file with secure permissions', async () => {
      const env = { ...process.env, HOME: testOutputDir };

      // Set a config value
      await execAsync(`node ${cliIndexPath} config set apiKey msc_test_key`, {
        cwd: generatedCliDir,
        timeout: 5000,
        env,
      });

      // Check file exists and has correct permissions
      const configPath = path.join(testOutputDir, '.msgcore', 'config.json');
      const stats = await fs.stat(configPath);

      // Check file permissions (should be 600 = owner read/write only)
      const mode = stats.mode & 0o777;
      expect(mode).toBe(0o600);
    }, 30000);

    it('should validate config keys', async () => {
      const env = { ...process.env, HOME: testOutputDir };

      // Try to set invalid key
      try {
        await execAsync(
          `node ${cliIndexPath} config set invalidKey someValue`,
          { cwd: generatedCliDir, timeout: 5000, env },
        );
        fail('Should have thrown error for invalid key');
      } catch (error: any) {
        expect(error.stderr || error.stdout).toContain('Invalid key');
        expect(error.stderr || error.stdout).toContain('apiUrl');
        expect(error.stderr || error.stdout).toContain('apiKey');
      }
    }, 30000);

    it('should handle empty config gracefully', async () => {
      const env = { ...process.env, HOME: testOutputDir };

      // Try to get value that doesn't exist
      const { stdout } = await execAsync(
        `node ${cliIndexPath} config get apiKey`,
        { cwd: generatedCliDir, timeout: 5000, env },
      );

      expect(stdout).toContain('not set');
    }, 30000);

    it('should handle empty config list', async () => {
      const env = { ...process.env, HOME: testOutputDir };

      const { stdout } = await execAsync(`node ${cliIndexPath} config list`, {
        cwd: generatedCliDir,
        timeout: 5000,
        env,
      });

      expect(stdout).toContain('No configuration set');
    }, 30000);
  });
});
